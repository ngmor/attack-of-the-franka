# ME495 Embedded Systems Final Project Attack of the Franka

## Team 
### Name: Attack of the Frankas (Group 2)
### Team Members:
 - Nick Morales
 - Megan Sindelar
 - Sushma Chandra
 - Vaishnavi Dornadula
### Robot Used: Franka
### Github Repository Link: 

`https://github.com/ngmor/attack-of-the-franka`

### Project Videos:
https://drive.google.com/file/d/1o-AKXsr8Wqxdj_DX8L0xjUgXkbujYIkm/view?usp=sharing
https://drive.google.com/file/d/1WRIVM4u_p33MkGhK_5lwX5Xugu6PrdSB/view?usp=sharing

Clean 1 ally 1 enemy shot:
https://drive.google.com/file/d/1_kVLCrcbNZSKzEiMgiprXgzdQIEo_umJ/view?usp=sharing

### Brief Description of Project:
Our project is to configure a robot autonomously wield a lightsaber to help the Rebellion fight the Empire, where the setup of the workspace is configured by a human. The robot holds the lightsaber in its grippers to knock over members of the Imperial Army, represented by red blocks placed upright on a table near the Franka robot. Franakin Skywalker will also need to avoid the blocks representing members of the Rebellion, marked by upright blue blocks. The system uses computer vision to differentiate the blocks.

### Summary of Project Capabilities (Goals Achieved): 
 - Robot picks up its lightsaber, recognizes which block it must knock over, and knocks over the “enemy” blocks without colliding into its “ally” blocks on the attack swing
 - Robot is able to avoid multiple allies and knock over multiple enemies.
 - Robot calculates whether knocking an enemy over will cause the falling block to collide with an ally, and therefore does not swing in that style (i.e. prioritize leaving allies standing over knocking over enemies)
 - Robot will check all its swing/attack styles before giving up on the attack and moving to next enemy

### High Level Workflow:
Upon launching the attack_of_the_franka launch file, the realsense camera and robot nodes will start running. An rviz simulation of the franka with the walls and ceiling will appear, as well as an rviz visualization of the transformations generated by the computer vision processing. Calling the /pickup_lightsaber service will command the robot to pick up the lightsaber from its sheath. Then, after calling the /look_for_enemies service, the robot will start planning attacks on all of the enemy red blocks. The decision tree of the workflow will evaluate three attack styles: a left swing, right swing, and stab. It will run through a sequence to determine which attack to perform in order to ensure it doesn’t knock over any blue blocks. If it is unable to attack an enemy, it will move on to the next one, until it is done with all reachable enemies.

### A discussion of the overall system architecture and high level concepts:
The entire motions is encapsulated in the robot_control node. The motion works by calling the /pickup_lightsaber service to add the lightsaber as a collision object in the scene, moving towards the lightsaber through specific end-effector waypoint pose. Then the lightsaber gets removed from the scene as a collision object and gets added as an attached collison object. The robot then grasps the lightsaber and returns to home. Then, by calling the /look_for_enemies service, all the allies in the scene will be added as collision objects. Then, the robot looks to the left-most enemy, detected and labeled through the computer vision node, and decides which of 3 path planning options to take. Two of the options are the left and right swings, both commanded by end-effector waypoint poses. These poses are determined by the locations detected through the transforms from the realsense camera. The last option is a stabbing motion, which is commanded through a combination of the position of the enemy, detected by the realsense, and set joint positions. The decision sequence works by first attempting to plan a left swing, then a right swing, and then a stabbing motion. The robot makes this decision based on where the allies are in the scene and if it can knock over the enemy block without knocking over any ally blocks. If the robot decides it cannot knock over an enemy block without knocking over any allies, then it will determine that it cannot go knock over that enemy and will move onto the next one. The robot will continue to do this exact sequence until all the reachable enemies have been knocked down.

### Any other information, as appropriate (lessons learned, future work):
#### Lessons Learned:

#### Future Work:
Future work we would like to incorporate would be to have more robust movements that could take the distance from an ally to adjust its swing waypoints. We would also like to adjust our gripper to be able to turn the lightsaber on when it picks it up. 

### Setup Instructions:
To clone all necessary repositories, clone this repository into the `src` directory in your workspace root. Then from the workspace root directory, run the command:

`vcs import . < src/attack-of-the-franka/project.repos`

(This assumes you don't change the name of the repository, update the path accordingly if you do.)

If you don't have `vcstool` installed, install it with:

`sudo apt install python3-vcstool`

### Quickstart Guide of Useful Commands:
#### Running Full Workflow:
`ros2 launch attack_of_the_franka attack_of_the_franka.launch.py`
    
#### Run Only Camera Functionality:
`ros2 launch attack_of_the_franka realsense.launch.py`

#### Run Only Robot Movement Related Programs:
`ros2 launch attack_of_the_franka robot.launch.py`

#### To Pick Up the Lightsaber from the Sheath:
`ros2 service call /pickup_lightsaber std_srvs/srv/Empty`

#### To Start Attacking Enemies
`ros2 service call /look_for_enemies std_srvs/srv/Empty`

#### Move to Home Position
`ros2 service call /move_to_home std_srvs/srv/Empty`

### List of all nodes and launchfiles and what they do:
#### Package Name: attack_of_the_franka
Type: ament_python
#### Nodes:
- camera_processor.py
    - Performs image processing for ally and enemy detection based on color.
    - Gets workspace area transforms and the robot transform
- common.py
    - A common library for functions/values used by all nodes
- robot_control.py
    - Runs the state machine related to motion and interacts with our moveit_interface API to plan and attack enemies. It processes camera information to locate allies and enemies and provides helpful services to do a variety of tasks with the lightsaber and blocks interaction. 
    simple_move
    - Controls robot and planning scene using the moveit_interface API.
#### Launchfiles:
- realsense.launch.py 
    - Launches the nodes needed to read in information from the RealSense camera and april tags to recognize the table and block locations relative to the robot base
- robot.launch.py 
    - Launches the robot_control node and other programs to view the rviz simulation of the franka robot
- attach_of_the_franka.launch.py       
    - combines the above two launch files to set up all the nodes needed to run the services and nodes needed to attack enemies
    moveit_testing.launch.py
- Launches the moveit launch file as well as out testing node named simple_move

### Helpful Services:
 - move_to_home (std_srvs.srv.Empty): moves the robot to a predetermined home position
 - gripper_open (std_srvs.srv.Empty): moves the robot's end-effector position to open
 - gripper_close (std_srvs.srv.Empty): moves the robot's end-effector position to close
 - gripper_grasp (std_srvs.srv.Empty): moves the robot's end-effector together until               it's grasping an object between them
 - waypoints (std_srvs.srv.Empty): commands the robot to move to a predetermined waypoint
 - test_joint_trajectory (std_srvs.srv.Empty): commands robot to a predetermined waypoint using the joint angles
 - move_to_pose (moveit_testing_interfaces/srv/MoveToPose): move robot to specific position and orientation
 - joint_waypoint (std_srvs.srv.Empty)
 - move_to_position (moveit_testing_interfaces/srv/MoveToPosition): move robot to specific position
 - move_to_orientation (moveit_testing_interfaces/srv/MoveToOrientation): move robot to specific orientation
 - update_obstacles (moveit_testing_interfaces/srv/UpdateObstacles): add obstacles to scene
 - pickup_lightsaber (std_srvs.srv.Empty): commands the robot to follow waypoints to pick up pick up the fixed lightsaber with the end-effector
 - update_persistent_obstacles (moveit_testing_interfaces.srv.UpdateObstacles): adds obstacle to scene permanently
 - update_attached_obstacles (moveit_testing_interfaces.srv.UpdateAttachedObstacles): adds obstacle attached to robot links
 - home_waypoint (std_srvs.srv.Empty): plans to a hard coded value in the callback
 - add_walls (std_srvs.srv.Empty): adds walls and ceiling collision objects to the planning scene
 - remove_separate_lightsaber (std_srvs.srv.Empty): removes the lightsaber as collision object
 - add_separate_lightsaber (std_srvs.srv.Empty): add lightsaber as a separate collision object
 - remove_attached_lightsaber (std_srvs.srv.Empty): remove the lightsaber attached to the end-effector in the planning scene in rviz
 - add_attached_lightsaber (std_srvs.srv.Empty): add the lightsaber attached to the end-effector to the planning scene as an attached collision object.
 - look_for_enemy (std_srvs.srv.Empty): check for any enemies detected in the planning scene and begins to calculate how to attack if possible
 - reset_allies (std_srvs.srv.Empty): updates the position of the allies in the planning scene to current
